!***********************************************************************
!                                                                      *
!JE   subroutine DENSNEW(DOIT,DINT1,DINT2,DINT3,DINT4,DINT5,DINT6,DINT7)
       subroutine DENSNEW_SELTZ(DOIT,DINT1,DINT2,DINT3,                &
                          DINT4,DINT5,DINT6,DINT7,                     &
                          DINT1VEC,DENS1VEC,NRNUC)
!                                                                      *
!   if angular coefficients must be calculated                         *
!   This routine controls combines the radial and angular parts for the*
!   calculation of the NMS parameter, the electron density at the      *
!   origin and radial expectation values.
!                                                                      *
!   Call(s) to: [LIB92]: ALCBUF, CONVRT, GETYN                         *
!                        ITJPO, ONESCALAR                              *
!                                                                      *
!   Written by Per Jonsson                                             *
!                                                                      *
!                                         Last revision: 10 Nov 1995   *
!                                                                      *
!   Modified by C. Naz\'e  Feb. 2012                                   *
!   Modified by J. Ekman   Nov. 2013                                   *
!                                                                      *
!***********************************************************************
!...Translated by Gediminas Gaigalas 11/18/19
!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------
      use iso_fortran_env, only: real64, int32, int64, real128
      use parameter_def,    ONLY: KEYORB, NNNW, NNNP
      use blk_C
      use debug_C
      use decide_C
      use DEF_C
      use eigv_C
      use foparm_C
      use grid_C
      use JLABL_C
      use npar_C
      use orb_C
      use prnt_C
      use TEILST_C
      use BUFFER_C
      use ris_C
      use syma_C
      use prnt_C,           ONLY : NVEC
!-----------------------------------------------
!   I n t e r f a c e   B l o c k s
!-----------------------------------------------
      use alcbuf_I
      use convrt_I
      use getyn_I
      use itjpo_I
      use onescalar_I
      IMPLICIT NONE
!-----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
      integer, intent(in) :: DOIT, NRNUC
      real(kind=real64), dimension(NNNW,NNNW), intent(in) :: DINT1, DINT2, &
                                                        DINT3, DINT4, &
                                                        DINT5, DINT6, &
                                                        DINT7
      real(kind=real64), dimension(NVEC,NRNUC), intent(out)     :: DENS1VEC !  JE ADD
      real(kind=real64), dimension(NNNW,NNNW,NRNUC), intent(in) :: DINT1VEC !  JE ADD
!-----------------------------------------------
!   L o c a l   P a r a m e t e r s
!-----------------------------------------------
      integer, parameter :: KEY = KEYORB
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      real(kind=real64), dimension(NNNW) :: TSHELL, TSHELL_S
      real(kind=real64), dimension(NRNUC) :: CONTRI1VEC, ELEMNT1VEC
      real(kind=real64), dimension(:), pointer :: EMT1, EMT2, EMT3, EMT4,   &
                                             EMT5, EMT6
      real(kind=real64) :: ELEMNT1, ELEMNT2, ELEMNT3, ELEMNT4, ELEMNT5,     &
                      ELEMNT6, ELEMNT7, CONTRI1, CONTRI2, CONTRI3,     &
                      CONTRI4, CONTRI5, CONTRI6, CONTRI7
      logical :: VSH, NUCDE, SMSSH, YES
      character :: CNUM*11, CK*2
      integer, dimension(NNNW) :: IA_S
      integer :: KA, IOPAR, INCOR, IC, LCNUM, ITJPOC, IR, IA, IB, I, II, J
      Integer :: L, LOC, NCONTR, LAB
!-----------------------------------------------
!
! DOIT: if DOIT=1 angular coefficients will be stored after creation
! DINT1 contain the density
! DINT2 contain the uncorrected NMS parameter: K^1_NMS
! DINT3 contain the expect. value <r>
! DINT4 contain the expect. value <r2>
! DINT5 contain the expect. value <r-1>
! DINT6 contain the expect. value <r-2>
! DINT7 contain the sum of NMS parameters: K^1_NMS+K^2_NMS+K^3_NMS
!
      DENS1VEC(:,:) = 0.0D00                                     ! JE ADD
!
!   Set the rank (zero) and parity (even) for the one-particle
!   coefficients
!
      KA = 0
      IOPAR = 1
      INCOR = 1
!
!   Allocate storage for the arrays in BUFFER
!
      CALL ALCBUF (1)
!
!   Sweep through the Hamiltonian matrix to determine the
!   sms parameter
!
         DO 13 IC = 1,NCF
!
!   Output IC on the screen to show how far the calculation has preceede
!
        CALL CONVRT (IC,CNUM,LCNUM)
        if (mod(IC,100).eq.0) then
          PRINT *, 'Column '//CNUM(1:LCNUM)//' complete;'
        end if
!
        ITJPOC = ITJPO (IC)

        DO 12 IR = IC,NCF
!
!   Matrix elements are diagonal in J
!
          if (ITJPO(IR) .EQ. ITJPOC) then
!
!   Initialise the accumulator
!
            ELEMNT1 = 0.0D00
            ELEMNT2 = 0.0D00
            ELEMNT3 = 0.0D00
            ELEMNT4 = 0.0D00
            ELEMNT5 = 0.0D00
            ELEMNT6 = 0.0D00
            ELEMNT7 = 0.0D00
            ELEMNT1VEC(:) = 0.0D00                                      ! JE ADD
!
!   Call the MCT package to compute T coefficients
!
           CALL ONESCALAR(IC,IR,IA,IB,TSHELL)
!GG            CALL TNSRJJ (KA,IOPAR,IC,IR,IA,IB,TSHELL)
            if (IA .NE. 0) then
              if (IA .EQ. IB) then
                    NCONTR = 0
                DO 8 IA = 1,NW
                  if (ABS (TSHELL(IA)) .GT. CUTOFF) then
                    NCONTR = NCONTR + 1
                    TSHELL_S(NCONTR) = TSHELL(IA)
                    IA_S(NCONTR) = IA
                    ELEMNT1 = ELEMNT1 + DINT1(IA,IA)*TSHELL(IA)
                    DO 21 L = 2,NRNUC                                    ! JE ADD
                      ELEMNT1VEC(L) = ELEMNT1VEC(L)+DINT1VEC(IA,IA,L)*& ! JE ADD
                                      TSHELL(IA)                        ! JE ADD
   21               CONTINUE                                            ! JE ADD
                    ELEMNT2 = ELEMNT2 + DINT2(IA,IA)*TSHELL(IA)
                    ELEMNT3 = ELEMNT3 + DINT3(IA,IA)*TSHELL(IA)
                    ELEMNT4 = ELEMNT4 + DINT4(IA,IA)*TSHELL(IA)
                    ELEMNT5 = ELEMNT5 + DINT5(IA,IA)*TSHELL(IA)
                    ELEMNT6 = ELEMNT6 + DINT6(IA,IA)*TSHELL(IA)
                    ELEMNT7 = ELEMNT7 + DINT7(IA,IA)*TSHELL(IA)
                  endif
    8           CONTINUE
                if (DOIT.EQ.1) WRITE(50) IC,IR,NCONTR
                DO I = 1,NCONTR
                  LAB = IA_S(I)*(KEY + 1)
                  if (DOIT.EQ.1) WRITE(50) TSHELL_S(I),LAB
                END DO
              else
                if (ABS (TSHELL(1)) .GT. CUTOFF) then
                  if (NAK(IA).EQ.NAK(IB)) then
                    if (DOIT.EQ.1) WRITE(50) IC,IR,1
                    LAB = IA*KEY + IB
                    if (DOIT.EQ.1) WRITE(50) TSHELL(1),LAB
                    ELEMNT1 = ELEMNT1 + DINT1(IA,IB)*TSHELL(1)
                    DO 23 L = 2,NRNUC                                   ! JE ADD
                      ELEMNT1VEC(L) = ELEMNT1VEC(L)+DINT1VEC(IA,IB,L)*& ! JE ADD
                                      TSHELL(1)                         ! JE ADD
   23               CONTINUE                                            ! JE ADD
                    ELEMNT2 = ELEMNT2 + DINT2(IA,IB)*TSHELL(1)
                    ELEMNT3 = ELEMNT3 + DINT3(IA,IB)*TSHELL(1)
                    ELEMNT4 = ELEMNT4 + DINT4(IA,IB)*TSHELL(1)
                    ELEMNT5 = ELEMNT5 + DINT5(IA,IB)*TSHELL(1)
                    ELEMNT6 = ELEMNT6 + DINT6(IA,IB)*TSHELL(1)
                    ELEMNT7 = ELEMNT7 + DINT7(IA,IB)*TSHELL(1)
                  endif
                endif
              endif
            endif
            DO 9 J = 1,NVEC
              LOC = (J-1)*NCF
              CONTRI1 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT1
              CONTRI1VEC(:) = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT1VEC(:)   ! JE ADD
              CONTRI2 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT2
              CONTRI3 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT3
              CONTRI4 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT4
              CONTRI5 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT5
              CONTRI6 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT6
              CONTRI7 = EVEC(IC+LOC)*EVEC(IR+LOC)*ELEMNT7
              if (IR.NE.IC) then
                CONTRI1 = 2.0D00 * CONTRI1
                CONTRI1VEC(:) = 2.0D00 * CONTRI1VEC(:)                  ! JE ADD
                CONTRI2 = 2.0D00 * CONTRI2
                CONTRI3 = 2.0D00 * CONTRI3
                CONTRI4 = 2.0D00 * CONTRI4
                CONTRI5 = 2.0D00 * CONTRI5
                CONTRI6 = 2.0D00 * CONTRI6
                CONTRI7 = 2.0D00 * CONTRI7
              endif
              DENS1(J) = DENS1(J) + CONTRI1
              DO 22 L = 2,NRNUC                                         ! JE ADD
                DENS1VEC(J,L) = DENS1VEC(J,L) + CONTRI1VEC(L)           ! JE ADD
   22         CONTINUE                                                  ! JE ADD
              DENS2(J) = DENS2(J) + CONTRI2
              DENS3(J) = DENS3(J) + CONTRI3
              DENS4(J) = DENS4(J) + CONTRI4
              DENS5(J) = DENS5(J) + CONTRI5
              DENS6(J) = DENS6(J) + CONTRI6
              DENS7(J) = DENS7(J) + CONTRI7
    9       CONTINUE
          endif
   12   CONTINUE
   13 CONTINUE
      if (DOIT.EQ.1) WRITE(50) -1
!
! Empty the buffer and close file
      if (DOIT.EQ.1) CLOSE(50)
!
!   Deallocate storage for the arrays in BUFFER
      CALL ALCBUF (3)
      return
      end subroutine DENSNEW_SELTZ
