!***********************************************************************
!                                                                      *
      subroutine LODCSL(NCORE)
!                                                                      *
!   Loads the data from the  .csl  file. A number of checks are made   *
!   to ensure correctness and consistency.                             *
!                                                                      *
!   Call(s) to: [LIB92]: ALLOC, CONVRT, IQ, ISPAR, ITJPO, JCUP, JQS,   *
!                        PACK, PARSJL, PRSRCN, PRSRSL                  *
!                                                                      *
!   Written by Farid A. Parpia            Last revision: 23 Dec 1992   *
!   Updated by Xinghong He                               29 Oct 1997   *
!       To accept both block and non-block formats                     *
!                                                                      *
!   Modified by G. Gaigalas,                                May 2011   *
!                                                                      *
!***********************************************************************
!...Translated by Pacific-Sierra Research 77to90  4.3E  13:07:22   2/14/04
!...Modified by Charlotte Froese Fischer
!                     Gediminas Gaigalas  10/05/17
!-----------------------------------------------
!   M o d u l e s
!-----------------------------------------------
      use iso_fortran_env, only: real64, int32, int64, real128
      use parameter_def,   ONLY: NNNW
      use DEBUG_C
      use DEF_C
      use ORB_C
      use STAT_C
      use TERMS_C,         only: jtab, ntab
      use IOUNIT_C
      use BLK_C,           only: NBLOCK,NCFBLK
      use memory_man
!-----------------------------------------------
!   I n t e r f a c e   B l o c k s
!-----------------------------------------------
      use prsrsl_I
      use convrt_I
      use prsrcn_I
      use parsjl_I
      use pack_I
      use iq_I
      use jqs_I
      use jcup_I
      use itjpo_I
      use ispar_I
      IMPLICIT NONE
!-----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
      integer,  intent(out) :: NCORE
!-----------------------------------------------
!   L o c a l   P a r a m e t e r s
!-----------------------------------------------
      integer, parameter :: NW2 = 2*NNNW
!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      integer, dimension(NNNW) :: IOCC
      integer, dimension(NW2)  :: IQSUB
      integer, dimension(NNNW) :: JX
      integer :: I
      integer :: NCORP1, NPEEL, NPEEL2, J, NPJ, NAKJ, LENTH, NCFD, NREC &
         , IOS, IERR, LOC, NQS, NEWSIZ, ISPARC, NJX, IOC, IPTY, NQSN    &
         , NJXN, NPEELN, NOPEN, JLAST, ILAST, IOCCI, NKJI, ifULLI, NU   &
         , JSUB, IQT, NBEG, NEND, JXN, JPI, II, ITEMP, NCOREL
      logical :: EMPTY, FULL
      character          :: RECL
      character(LEN=256) :: RECORD
!-----------------------------------------------
!
!
!   Entry message
!
      WRITE (6, *) 'Loading Configuration Symmetry List File ...'
!
!   Get the list of subshells
!
      NW = 0
!
!   Read the list of core subshells; set up the arrays NP, NAK,
!   NKL, NKJ, NH for these subshells
!
      CALL PRSRSL (21, 1)
      NCORE = NW
      NCORP1 = NW + 1
!
!   Skip the peel subshell identification header; read the list of
!   peel subshells; set up the arrays NP, NAK, NKL, NKJ, NH for
!   these subshells
!
      READ (21, *)
      CALL PRSRSL (21, 2)
      NPEEL = NW - NCORE
      NPEEL2 = NPEEL*2
!
!   Ensure that the sets of core and peel subshell are disjoint
!
      DO J = NCORE + 1, NW
         NPJ = NP(J)
         NAKJ = NAK(J)
         DO I = 1, NCORE
            if (NP(I)/=NPJ .OR. NAK(I)/=NAKJ) CYCLE
            WRITE (ISTDE, *) 'LODCSL: The lists of core and', &
               ' peel subshells must form disjoint sets.'
            STOP
         END DO
      END DO
!
!   Print the number of relativistic subshells
!
      if (NW > 1) then
         CALL CONVRT (NW, RECORD, LENTH)
         WRITE (6, *) 'There are '//RECORD(1:LENTH)// &
                      ' relativistic subshells;'
      else
         WRITE (6, *) 'There is 1 relativistic subshell;'
      endif
!
!   Initial allocation for arrays with a dimension dependent
!   on the number of CSFs; the initial allocation must be
!   greater than 1
!
      NCFD = 6000
!     NCFD = 2

       CALL ALLOC (IQA,  NNNW,  NCFD, 'IQA',   'LODCSL')
       CALL ALLOC (JQSA, NNNW,3,NCFD, 'JQSA',  'LODCSL')
       CALL ALLOC (JCUPA,NNNW,  NCFD, 'JCUPA', 'LODCSL')

!
!   Skip the header for the list of CSFs
!
      READ (21, *)
!
!   NREC is the sequence number of the last record read in the
!   Configuration Symmetry List File
!
      NREC = 5
!
!   There must be three records for each CSF: For instance,
!
!    4s ( 2) 4p-( 2) 4p ( 3) 4d-( 2) 4d ( 5) 4f-( 6) 4f ( 4)
!                        3/2       0     5/2             2;4
!                                           1               3-
!   Each record is as follows:
!      (1) Peel subshell occupation number (q) specification.
!      (2) Subshell total angular momentum quantum number
!          (v_, J_sub) specifications. Subshell total angular
!          momentum quantum numbers (J_sub) must be specified
!          for all open subshells, even if this can be
!          deduced from the subshell occupation. Seniority
!          quantum numbers (v) must be specified for
!          subshells with j = 7/2, q = 4, J_sub = 2 or 4.
!          The seniority quantum number must precede the
!          total angular momentum quantum number: in the
!          example above, for the 4f_7/2 subshell, q = 4
!          and J_sub = 4, whence it is necessary to specify
!          v --- 2 in this case.
!      (3) The minimum number of intermediate angular
!          momentum quantum numbers (X) as well as the final
!          angular momentum quantum number (J) immediately
!          followed by the sign of the parity (P) must be
!          specified on this record. In the example above,
!          the J_sub = 0 for the 4d_3/2 subshell, whence
!          it is unnecessary to specify its coupling to all
!          preceding subshells.
!   These conventions have been chosen so as to render the CSF
!   specifications easily interpreted by the user
!
      NCF = 0
      NBLOCK = 0
    3 CONTINUE
      NCF = NCF + 1
!
      READ (21, '(A)', IOSTAT=IOS) RECORD
!**********************************************************************
!blk*
!   To skip the border line added to mark the end of a block
!
      if (RECORD(1:2) == ' *') then
         NBLOCK = NBLOCK + 1
         NCFBLK(NBLOCK) = NCF -1
         READ (21, '(A)', IOSTAT=IOS) RECORD
      endif
!**********************************************************************

      if (IOS == 0) then
!
!   Read in the occupations (q) of the peel shells; stop with a
!   message if an error occurs
!
         CALL PRSRCN (RECORD, NCORE, IOCC, IERR)
         if (IERR /= 0) GO TO 26
!
!   Read the J_sub and v quantum numbers
!
         READ (21, '(A)', IOSTAT=IOS) RECORD
         if (IOS /= 0) then
            WRITE (ISTDE, *) 'LODCSL: Expecting subshell quantum', &
               ' number specification;'
            GO TO 26
         endif
         LOC = LEN_TRIM(RECORD)
         CALL PARSJL (1, NCORE, RECORD, LOC, IQSUB, NQS, IERR)
         if (IERR /= 0) GO TO 26
!
!   Read the X, J, and (sign of) P quantum numbers
!
         READ (21, '(A)', IOSTAT=IOS) RECORD
         if (IOS /= 0) then
            WRITE (ISTDE, *) 'LODCSL: Expecting intermediate ', &
               'and final angular momentum'
            WRITE (ISTDE, *) 'quantum number and final parity ', &
               'specification;'
            GO TO 26
         endif
!
!   Allocate additional storage if necessary
!
!CFF     It is possible that this should be moved to "3 Continue"
!        where NCF is incremented
         if (NCF > NCFD) then
            NEWSIZ = NCFD + NCFD/2
            CALL RALLOC (IQA,  NNNW,  NEWSIZ, 'IQA',   'LODCSL')
            CALL RALLOC (JQSA, NNNW,3,NEWSIZ, 'JQSA',  'LODCSL')
            CALL RALLOC (JCUPA,NNNW,  NEWSIZ, 'JCUPA', 'LODCSL')
            NCFD = NEWSIZ
         endif
!
!   Zero out the arrays that store packed integers
!
         DO I = 1,NNNW
            IQA(I,NCF)    = 0
            JQSA(I,1,NCF) = 0
            JQSA(I,2,NCF) = 0
            JQSA(I,3,NCF) = 0
            JCUPA(I,NCF)  = 0
         END DO
!
!   Determine the parity and all intermediate and the final
!   angular momentum quantum numbers
!
         DO I = 256, 1, -1
            if (RECORD(I:I) == ' ') CYCLE
            LOC = I
            EXIT
         END DO
         RECL = RECORD(LOC:LOC)
         if (RECL == '+') then
            ISPARC = 1
         else if (RECL == '-') then
            ISPARC = -1
         else
            WRITE (ISTDE, *) 'LODCSL: Incorrect parity ', &
                             'specification;'
            GO TO 26
         endif
         LOC = LOC - 1
!
         CALL PARSJL (2, NCORE, RECORD, LOC, JX, NJX, IERR)
         if (IERR /= 0) GO TO 26
!
!   Set the occupation and subshell quantum number array elements
!   in IQ, JQS for the core subshells
!
         DO I = 1, NCORE
            CALL PACK (NKJ(I) + 1, I, IQA(1:NNNW,NCF))
            CALL PACK (0, I, JQSA(1:NNNW,1,NCF))
            CALL PACK (0, I, JQSA(1:NNNW,2,NCF))
            CALL PACK (1, I, JQSA(1:NNNW,3,NCF))
         END DO
!
!   Check all subshell, intermediate and final angular momentum
!   quantum numbers; set the array elements in IQ, JQS for the peel
!   subshells; set the coupling array element in JCUP and the total
!   angular momentum array element in ITJPO
!
         IOC = 0
         IPTY = 0
         NQSN = 0
         NJXN = 0
         NPEELN = 0
         NOPEN = 0
         JLAST = 0
         ILAST = 0
         DO I = NCORP1, NW
            IOCCI = IOCC(I)
            NPEELN = NPEELN + IOCCI
            NKJI = NKJ(I)
            ifULLI = NKJI + 1
            EMPTY = IOCCI == 0
            if (.NOT.EMPTY) IOC = IOC + 1
            FULL = IOCCI == ifULLI
            if (EMPTY .OR. FULL) then
               NU = 0
               JSUB = 0
            else
               IPTY = IPTY + NKL(I)*IOCCI
               if (NKJI /= 7) then
                  NQSN = NQSN + 1
                  if (NQSN > NQS) then
                     WRITE (ISTDE, *) 'LODCSL: Too few subshell quantum', &
                        ' numbers specified;'
                     GO TO 26
                  endif
                  NU = 0
                  JSUB = IQSUB(NQSN)
               else
                  if (IOCCI /= 4) then
                     NQSN = NQSN + 1
                     if (NQSN > NQS) then
                        WRITE (ISTDE, *) 'LODCSL: Too few subshell ', &
                           'quantum numbers specified;'
                        GO TO 26
                     endif
                     NU = 0
                     JSUB = IQSUB(NQSN)
                  else
                     NQSN = NQSN + 1
                     if (NQSN > NQS) then
                        WRITE (ISTDE, *) 'LODCSL: Too few subshell ', &
                           'quantum numbers specified;'
                        GO TO 26
                     endif
                     JSUB = IQSUB(NQSN)
                     if (JSUB==4 .OR. JSUB==8) then
                        NU = JSUB/2
                        NQSN = NQSN + 1
                        if (NQSN > NQS) then
                           WRITE (ISTDE, *) 'LODCSL: Too few subshell', &
                              ' quantum numbers specified;'
                           GO TO 26
                        endif
                        JSUB = IQSUB(NQSN)
                     else
                        NU = 0
                     endif
                  endif
               endif
               IQT = MIN(IOCCI,ifULLI - IOCCI)
               LOC = (ifULLI - 2)/2
               LOC = (LOC*(LOC + 1))/2 + IQT
               NBEG = JTAB(LOC+1) + 1
               NEND = JTAB(LOC+2)
               DO J = NBEG, NEND, 3
                  if (NTAB(J+2) /= JSUB + 1) CYCLE
                  if (NU == 0) then
                     NU = NTAB(J)
                     GO TO 9
                  else
                     if (NTAB(J) == NU) GO TO 9
                  endif
               END DO
               CALL CONVRT (NP(I), RECORD, LENTH)
               WRITE (ISTDE, *) 'LODCSL: Subshell quantum numbers ', &
                  'specified incorrectly for '//RECORD(1:LENTH)//NH(I)//&
                  ' subshell.'
               GO TO 26
            endif
    9       CONTINUE
            if (.NOT.EMPTY .AND. .NOT.FULL) then
               NOPEN = NOPEN + 1
               if (NOPEN > 1) then
                  if (JSUB == 0) then
                     JXN = JLAST
                  else
                     ILAST = IOC
                     NJXN = NJXN + 1
                     if (NJXN > NJX) then
                        WRITE (ISTDE, *) 'LODCSL: Too few intermediate', &
                           ' and final angular momentum', &
                           ' quantum numbers specified;'
                        GO TO 26
                     endif
                     JXN = JX(NJXN)
                     DO J = ABS(JLAST - JSUB), JLAST + JSUB, 2
                        if (JXN == J) GO TO 11
                     END DO
                     CALL CONVRT (NP(I), RECORD, LENTH)
                     WRITE (ISTDE, *) &
                        'LODCSL: coupling of '//RECORD(1:LENTH)//NH(I),&
                        ' subshell to previous subshells is incorrect.'
                     GO TO 26
                  endif
   11             CONTINUE
                  CALL PACK (JXN + 1, NOPEN - 1, JCUPA(1:NNNW,NCF))
                  JLAST = JXN
               else
                  JLAST = JSUB
               endif
            endif
            CALL PACK (IOCCI, I, IQA(1:NNNW,NCF))
            CALL PACK (NU, I, JQSA(1:NNNW,1,NCF))
            CALL PACK (0, I, JQSA(1:NNNW,2,NCF))
            CALL PACK (JSUB + 1, I, JQSA(1:NNNW,3,NCF))
         END DO
!
         DO I = MAX(1,NOPEN), NW
            CALL PACK (0, I, JCUPA(1:NNNW,NCF))
         END DO
!
         if (NQSN /= NQS) then
            WRITE (ISTDE, *) 'LODCSL: Too many subshell', &
               ' quantum numbers specified;'
            GO TO 26
         endif
!
         if (ILAST /= IOC) NJXN = NJXN + 1
         if (NJXN /= NJX) then
            WRITE (ISTDE, *) 'LODCSL: Too many intermediate', &
            ' and final angular momentum', ' quantum numbers specified;'
            GO TO 26
         endif
!
         if (JX(NJXN) /= JLAST) then
            WRITE (ISTDE, *) 'LODCSL: Final angular momentum', &
               ' incorrectly specified;'
            GO TO 26
         endif
!
         IPTY = (-1)**IPTY
         if (IPTY /= ISPARC) then
            WRITE (ISTDE, *) 'LODCSL: Parity specified incorrectly;'
            GO TO 26
         endif
!
         JPI = (JLAST + 1)*IPTY
         CALL PACK (JPI, NNNW, JCUPA(1:NNNW,NCF))
!
         if (NCF > 1) then
            if (NPEELN /= NPEEL) then
               WRITE (ISTDE, *) 'LODCSL: Inconsistency in the number', &
                  ' of electrons.'
               GO TO 26
            endif
         else
            NPEEL = NPEELN
         endif
!
!   Check if this CSF was already in the list; stop with a
!   message if this is the case
!
         if (NCF > 1) then
            DO J = 1, NCF - 1
               DO I = NCORP1, NW
                  if (IQ(I,J) /= IQ(I,NCF)) GO TO 17
                  if (JQS(1,I,J) /= JQS(1,I,NCF)) GO TO 17
                  if (JQS(2,I,J) /= JQS(2,I,NCF)) GO TO 17
                  if (JQS(3,I,J) /= JQS(3,I,NCF)) GO TO 17
               END DO
               DO I = 1, NOPEN - 1
                  if (JCUP(I,J) /= JCUP(I,NCF)) GO TO 17
               END DO
            END DO
            WRITE (ISTDE, *) 'LODCSL: Repeated CSF;'
            GO TO 26
         endif
!
!   Successfully read a CSF; update NREC and read another CSF
!
   17    CONTINUE
         NREC = NREC + 3
         GO TO 3
!
      else
!
!   There is always at least one CSF
!
         if (NCF == 1) then
            DO I = 1, NCORE
               CALL PACK (NKJ(I) + 1, I, IQA(1:NNNW,1))
               CALL PACK (0, I, JQSA(1:NNNW,1,1))
               CALL PACK (0, I, JQSA(1:NNNW,2,1))
               CALL PACK (1, I, JQSA(1:NNNW,3,1))
            END DO
            CALL PACK (0, 1, JCUPA(1:NNNW,1))
            CALL PACK (1, NNNW, JCUPA(1:NNNW,1))
         else
            NCF = NCF - 1
         endif
!
      endif
!
!   Check if any subshell is empty; eliminate it from the
!   list if this is the case; issue a message
!
      I = NCORP1
   19 CONTINUE
      if (I <= NW) then
         DO J = 1, NCF
            if (IQ(I,J) /= 0) GO TO 23
         END DO
         CALL CONVRT (NP(I), RECORD, LENTH)
         WRITE (6, *) 'Subshell '//RECORD(1:LENTH)//NH(I)//' is empty', &
            ' in all CSFs; eliminating this', ' subshell from the list;'
         NW = NW - 1
         DO II = I, NW
            NP(II) = NP(II+1)
            NAK(II) = NAK(II+1)
            NKL(II) = NKL(II+1)
            NKJ(II) = NKJ(II+1)
            NH(II) = NH(II+1)
            DO J = 1, NCF
               ITEMP = IQ(II + 1,J)
               CALL PACK (ITEMP, II, IQA(1:NNNW,J))
               ITEMP = JQS(1,II + 1,J)
               CALL PACK (ITEMP, II, JQSA(II:NNNW,1,J))
               ITEMP = JQS(2,II + 1,J)
               CALL PACK (ITEMP, II, JQSA(II:NNNW,2,J))
               ITEMP = JQS(3,II + 1,J)
               CALL PACK (ITEMP, II, JQSA(II:NNNW,3,J))
            END DO
         END DO
   23    CONTINUE
         I = I + 1
         GO TO 19
      endif
!
!   Store the number of electrons in the COMMON variable
!
      NCOREL = 0
      NCOREL = SUM(NKJ(:NCORE)+1)
      NELEC = NCOREL + NPEEL
!
!   All done; report
!
      CALL CONVRT (NCF, RECORD, LENTH)
      WRITE (6, *) 'There are '//RECORD(1:LENTH)//' relativistic CSFs;'
      WRITE (6, *) ' ... load complete;'
!
!   Debug printout
!
      if (LDBPA(1)) then
         WRITE (99, *) 'From LODCSL:'
         DO I = 1, NCF
            WRITE (99, *) 'CSF ', I
            WRITE (99, *) 'ITJPO: ', ITJPO(I)
            WRITE (99, *) 'ISPAR: ', ISPAR(I)
            WRITE (99, *) 'IQ: ', (IQ(J,I),J=1,NW)
            WRITE (99, *) 'JQS(1): ', (JQS(1,J,I),J=1,NW)
            WRITE (99, *) 'JQS(2): ', (JQS(2,J,I),J=1,NW)
            WRITE (99, *) 'JQS(3): ', (JQS(3,J,I),J=1,NW)
            WRITE (99, *) 'JCUP: ', (JCUP(J,I),J=1,NW - 1)
         END DO
      endif


      NBLOCK = NBLOCK + 1
      NCFBLK(NBLOCK) = NCF
!
      return
!
   26 CONTINUE
      CALL CONVRT (NCF, RECORD, LENTH)
      WRITE (ISTDE, *) ' CSF sequence number: '//RECORD(1:LENTH)//':'
      REWIND (21)
      DO I = 1, NREC
         READ (21, *)
      END DO
      DO I = 1, 3
         READ (21,'(A)',ERR = 29,END = 29) RECORD
         LENTH = LEN_TRIM(RECORD)
         WRITE (ISTDE, *) RECORD(1:LENTH)
      END DO
   29 CLOSE(21)
      STOP
!
      end subroutine LODCSL
